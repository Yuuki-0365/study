整除
当a=bk,且a,b,k均为整数时，称为b整除a，记为b|a

b为除数，a为被除数。

质数与合数
质数与合数的定义不再赘述。

不大于n的质数约有nlnn个

带余除法、同余
a≡b(modc)，表示a%c=b%c

性质:a≡b(modc)与c|(a−b)等价

推论:若a≡b(modc),d|c，则a≡b(modd)

GCD
一些性质：(0,a)=a,(a,b)=(a,a+b)=(a,ka+b)

第一条性质：由于任何数都整除0，所以任何数都是0的约数，由此易得。

第二条性质：由c|a,c|b⇔c|(a+b) ，易得。

由此可以证明欧几里得算法的正确性，即(a,b)=(a,b%a)

EXGCD
用于求解形如ax+by=k的不定方程。

方程有解当且仅当(a,b)|k。

示例：EXGCD证明裴蜀定理

r=a%b,a>b,d=(a,b)
​ 求解：ax+by=d

​ 可以得到a=kb+r(r≤b),根据欧几里得算法(a,b)=(b,a%b)=(b,r)，且在算法的最后一定会得到(d,0)=d

​ dx+0y=d显然有解x=1,y=0

已知bx0+ry0ax+by(kb+r)x+byb(kx+y)+rx所以x=y0,y=d=d=d=d=x0−ky0(1)(2)(3)(4)(5)
​ 因此必然存在一组解，使ax+by=(a,b)成立。

当然，这个过程也得出了EXGCD的递归模式。

对于求不定方程多组解的问题，我们通常使用这样的方法：

首先用EXGCD求出一个特殊解x0,y0，然后构造出ax+by=0的通解，也就是x=b(a,b),y=−a(a,b)

然后令x=x0+b(a,b),y=y0−a(a,b)

由于一个数（模数小于该数）取模之后至多为原来的一半，所以时间复杂度为O(log2n)

例题
Luogu P3951 小凯的疑惑

题意大致为(a,b)=1∀x,y∈N,ax+by不能表示的最大数值。

假设这个数为k−1，那么显然我们可以构造出①：ax+by=k。

根据题意可以得到②：ax0+by0=1，显然此时x0,y0不可能同号。假设xmin,ymin为ax+by=1中x,y分别最小的非负整数解。

①−②得a(x−x0)+b(y−y0)=k−1，根据裴蜀定理，此方程必定有解。又从题目条件推导，可以得到x−x0<0或y−y0<0

若x0=xmin，此时对应的y0为负数，所以y−y0>0，由此可以得到x−xmin<0

同理可以得到y−ymin<0。

同时符合两个约束的时候的时候，此时的k−1是不合法的。

在仅符合一个约束时，若仅符合第一个约束，则有y−ymin≥0那么当y=ymin时，x−x0>0，不合题意。

由于我们要寻求最大值的k，所以x,y尽可能大，所以x=xmin−1,y=ymin−1。

逆元
若ax≡1(modb)，则称x是a关于模b的逆元，记作a−1

在高中与初中的数学中，我们把这样具有类似这种性质的数称之为倒数。

事实上，它们的意义是相似的，可以将除法运算转化为乘法运算，便于求余。

在上述式子中，ca=c∗x。

可以发现上述式子等价于ax+by=1⇔(a,b)=1，直接利用EXGCD求解即可。

通常模数p为质数。

当我们要求[1,n]的逆元时，当n足够大时，EXGCD就显得不太够用了。

对于这样的问题我们有如下公式推导：

假定我们要求i的逆元，模数为p（p为质数）。

显然可以得到p=ki+r，因为p为质数，所以r!=0，即存在r的逆元。

ki+rki+r两边同时乘r−1i−1,得到：kr−1+i−1根据同余式的性质，得到：i−1i−1i−1≡p(modp)≡0(modp)≡0(modp)≡−kr−1(modp)≡(−p/i)∗r−1(modp)≡(p−p/i)∗r−1(modp)(6)(7)(8)(9)(10)(11)
线性同余方程
形如ax≡c(modb)，称为线性同余方程。

等价于ax+by=c，有解条件为(a,b)|c

对于线性同余方程组，有一种可行的解法：

⎧⎩⎨⎪⎪⎪⎪⎪⎪x≡2(mod3)x≡3(mod5)x≡5(mod7)...(12)
设x=3a+2，代入第二条得到3a+2≡3(mod5)，解得a≡2(mod5)。设a=5b+2，代入第三条得到3(5b+2)+2≡5(mod7)，显然有b≡4(mod7)

最后代回x=3a+2即可得到x在模105意义下的唯一解。

中国剩余定理
对于模数两两互质的线性同余方程组，如

⎧⎩⎨⎪⎪⎪⎪⎪⎪x≡a1(modm1)x≡a2(modm2)x≡a2(modm2)...(13)
其中m1,m2,...,mn两两互质，定理给出了构造解的方法。

设M=∏ni=1mi,Mi=Mmi。

显然Mi与mi互质，存在Mi在模mi意义下的逆元ti且∀j!=i,Mi≡0(modmj)

此时有解x≡∑ni=1aiMiti(modM)

可以自行验证。

卢卡斯定理
对于组合数取模问题，有卢卡斯定理：

C(m,n)≡C(m/p,n/p)∗C(m%p,n%p)(modp)
证明：不会

Luogu P3807 卢卡斯定理

预处理出阶乘和逆元，直接利用上述式子递归求解即可。

注意边界条件：

​ 1.当m<n，有C(m,n)=0。

​ 2.当n=0，有C(m,n)=1。

欧拉函数
欧拉函数φ(n)表示区间[1,n]与n互质的数的个数。

推论：

若n为质数，则φ(n)=n−1。
当n≥3,则φ(n)为偶数。
欧拉函数是积性函数，当gcd(a,b)=1，有φ(a∗b)=φ(a)∗φ(b)
若n=pk，p为质数，则有φ(n)=n(1−1/p)
基于性质4，可以推导出：若n有k个不同的质因子，分别为：p1,p2,p3...pk，那么φ(n)=n(1−1/p1)(1−1/p2)(1−1/p3)...(1−1/pk)
性质1不证自明。

性质2只需要证明若(a,n)=1，则(n−a,a)=1。反证法易得。

性质3证明如下：

​ 定义集合A(n)={x|x∈[1,n],(x,n)=1}。

​ 在A(a)和A(b)中任取两个元素a0,b0，构造线性同余方程组{x≡a0(moda),x≡b0(modb)}，利用中国剩余定理构造出一个唯一对应的元素x≡c(modab)。

显然有(c,a)=(a,c%a)=(a,a0)=1，同理有(c,b)=1，则说明(a0,b0)对应唯一的元素c∈A(ab)。

反之任取A(ab)的一个元素c，可以构造出a0=c%a,b0=c%b。

显然有(c,a)=(c,b)=1，所以有(a,a0)=(b,b0)=1。也就是说A(ab)中的任意一个元素对应一组有序实数对(a0,b0)，其中a0∈A(a),b0∈A(b)。

综上所述，A(a),A(b)的笛卡尔积（直积）与A(ab)构成双射。

于是命题得证。

性质4证明如下：∀x∈[1,n]，如果有(n,x)>1，则显然有p|x，可以得到这样的x有n/p个，那么剩下的数就有n−n/p，所以φ(n)=n(1−1/p)

性质5证明如下：将n分解质因数，套用性质4和性质3，即可证明。

笛卡尔积
又称直积，集合A,B的笛卡尔积为集合{(a,b)|a∈A,b∈B}

欧拉定理
若(a,n)=1，则aφ(n)≡1(modn)。

若n为质数，则有an−1≡1(modn)，即费马小定理。

证明：待填坑

欧拉定理求逆元
a∗aφ(n)−1≡1(modn)

利用快速幂求解即可。

欧拉定理缩小指数
求abmodp时，如果(a,p)=1，则可以得到aφ(p)≡1(modp)，所以ab≡abmodφ(p)modp

拓展欧拉定理
a2φ(n)≡aφ(n)(modn)

求abmodp时，若b≥φ(p)，则ab≡abmodφ(p)+φ(p)(modp)

欧拉函数的求法1（质因数分解，只求单个）
int phi(int n)
{
    int ret=n;
    for (int i=2;i*i<=n;i++)
    {
        if (n%i==0)
        {
        	while(n%i==0) n/=i;
        	ret=ret/i*(i-1);//相当于*(1-1/p)   
        }
    }
    if (n>1) ret=ret/n*(n-1);
    return ret;
}
时间复杂度：O(n−−√)

欧拉函数的求法2（线性筛法，求出1~n）
int phi(int n)
{
    for (int i=2;i<=n;i++)
    {
        if (v[i]==0) 
        {
            v[i]=i;
            rec[++cnt]=i;
            phi[i]=i-1;//p为质数时，phi(p)=p-1
        }
        for (int j=1;j<=cnt;j++)
        {
            if (rec[j]>v[i]||rec[j]>n/i) break;
            v[i*rec[j]]=rec[j];
            if (i%rec[j]!=0) phi[i*rec[j]]=phi[i]*phi[rec[j]];//符合积性函数的条件
            else phi[i*rec[j]]=phi[i]*rec[j];//详细见下面的分析
        }
    }
}
众所周知：当p为质数时φ(pk)=pk(1−1/p)。（证明上面有）

那么φ(pk−1)=pk−1(1−1/p)，两边同时乘p，得到：p∗φ(pk−1)=pk(1−1/p)。

由上可得，φ(pk)=p∗φ(pk−1)。

如果imodp=0且p为质数，意味着i=pk或者i=pk∗q。

若i=pk，则φ(i)=p∗φ(pk−1)，此时pk−1就是我们当前的合数，即程序中的第一重循环。

若i=pk∗q，则φ(i)=p∗φ(pk−1)∗φ(q)=p∗φ(pk−1∗q)，可以发现此时pk−1∗q，也是我们当前的合数。

那么程序中的语句就分析完毕了。

时间复杂度：O(n)。